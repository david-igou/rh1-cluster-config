# Deployment Guide - ApplicationSet Managed AAP Platform

**Last Updated**: 2025-11-04
**Repository**: rh1-cluster-config
**Pattern**: ApplicationSet with Auto-Discovery

## üéØ What You'll Deploy

With just **2 manual commands**, ArgoCD will automatically deploy:

- ‚úÖ 3 AAP environments (dev, qa, prod) - each with its own operator
- ‚úÖ OpenShift Pipelines operator
- ‚úÖ Tekton CI/CD pipelines for Ansible collections and EEs
- ‚úÖ All necessary namespaces and operators

## üìã Prerequisites

### 1. OpenShift Cluster Ready
- OpenShift 4.12+
- Cluster admin access
- Sufficient resources for AAP deployments

### 2. Git Repository Forked/Cloned

‚úÖ Fork or clone this repository:
- `https://github.com/djdanielsson/rh1-cluster-config.git`

**Note**:
- Namespaces are created automatically by each application
- AAP admin passwords are auto-generated by the operator
- ApplicationSet automatically discovers new directories in `applications/`

### 3. CLI Tools Installed

Required tools on your local machine:
- `oc` (OpenShift CLI) v4.12+
- `git`
- Optional: `argocd` CLI for advanced management

## üöÄ Deployment Steps

### Step 1: Install OpenShift GitOps Operator (Manual)

This is the **only operator** you install manually:

```bash
# Clone repository
git clone https://github.com/djdanielsson/rh1-cluster-config.git
cd rh1-cluster-config

# Login to OpenShift
oc login --server=https://api.your-cluster.com:6443

# Install OpenShift GitOps Operator
oc apply -f bootstrap-openshift-gitops/openshift-gitops-operator-subscription.yml

# Wait for operator to be ready (2-3 minutes)
echo "Waiting for OpenShift GitOps operator to be ready..."
oc wait --for=condition=Ready pod \
  -l name=openshift-gitops-operator \
  -n openshift-operators \
  --timeout=300s

echo "‚úì OpenShift GitOps operator is ready"
```

### Step 2: Deploy ApplicationSet (Manual)

This **ApplicationSet** automatically discovers and deploys all applications:

```bash
# Apply the ApplicationSet
oc apply -f bootstrap-openshift-gitops/cluster-applicationset.yml

echo "‚úì ApplicationSet created"
echo ""
echo "ArgoCD will now automatically discover and sync all applications in applications/*"
echo "This will take approximately 10-15 minutes."
```

### Step 3: Watch ArgoCD Auto-Deploy Everything

```bash
# Watch Applications being created (one per applications/* directory)
watch oc get applications -n openshift-gitops

# Or view in ArgoCD UI
ARGOCD_URL=$(oc get route openshift-gitops-server -n openshift-gitops -o jsonpath='{.spec.host}')
echo "ArgoCD UI: https://${ARGOCD_URL}"
echo ""
echo "Login with your OpenShift credentials"
```

**What's happening during sync:**

The ApplicationSet discovers each directory in `applications/` and creates an Application for it:

| Application | Resources | Time | Status Check |
|------------|-----------|------|--------------|
| aap-dev | Namespace, OperatorGroup, Subscription, AAP CR | 5-7 min | `oc get ansibleautomationplatform -n aap-dev` |
| aap-qa | Namespace, OperatorGroup, Subscription, AAP CR | 5-7 min | `oc get ansibleautomationplatform -n aap-qa` |
| aap-prod | Namespace, OperatorGroup, Subscription, AAP CR | 5-7 min | `oc get ansibleautomationplatform -n aap-prod` |
| openshift-pipelines | Subscription (cluster-scoped) | 3-5 min | `oc get csv -n openshift-operators \| grep pipelines` |
| ansible-molecule-ci | Namespace, Repository CR | 30s | `oc get repository -n ansible-molecule-ci` |
| ee-builder-ci | Namespace, Repository CR | 30s | `oc get repository -n ee-builder-ci` |

### Step 4: Verify Deployment

```bash
# Check all Applications are synced
oc get applications -n openshift-gitops

# Expected Applications:
# NAME                   SYNC STATUS   HEALTH STATUS
# aap-dev                Synced        Healthy
# aap-qa                 Synced        Healthy
# aap-prod               Synced        Healthy
# openshift-pipelines    Synced        Healthy
# ansible-molecule-ci    Synced        Healthy
# ee-builder-ci          Synced        Healthy

# Check AAP instances are running
oc get ansibleautomationplatform -A

# Expected output:
# NAMESPACE   NAME       AGE
# aap-dev     aap-dev    10m
# aap-qa      aap-qa     10m
# aap-prod    aap-prod   10m

# Check operators are installed
oc get csv -n aap-dev,aap-qa,aap-prod

# Get AAP admin passwords
echo "Dev password: $(oc get secret aap-dev-admin-password -n aap-dev -o jsonpath='{.data.password}' | base64 -d)"
echo "QA password: $(oc get secret aap-qa-admin-password -n aap-qa -o jsonpath='{.data.password}' | base64 -d)"
echo "Prod password: $(oc get secret aap-prod-admin-password -n aap-prod -o jsonpath='{.data.password}' | base64 -d)"
```

## üîß Post-Deployment Configuration

### 1. Access AAP Instances

Get the URLs and admin credentials for each AAP environment:

```bash
# Get AAP URLs
echo "Dev AAP:  https://$(oc get route aap-dev-service -n aap-dev -o jsonpath='{.spec.host}' 2>/dev/null || echo 'Route not yet created')"
echo "QA AAP:   https://$(oc get route aap-qa-service -n aap-qa -o jsonpath='{.spec.host}' 2>/dev/null || echo 'Route not yet created')"
echo "Prod AAP: https://$(oc get route aap-prod-service -n aap-prod -o jsonpath='{.spec.host}' 2>/dev/null || echo 'Route not yet created')"

# Get admin passwords
echo ""
echo "Admin username: admin"
echo "Dev password: $(oc get secret aap-dev-admin-password -n aap-dev -o jsonpath='{.data.password}' | base64 -d)"
echo "QA password: $(oc get secret aap-qa-admin-password -n aap-qa -o jsonpath='{.data.password}' | base64 -d)"
echo "Prod password: $(oc get secret aap-prod-admin-password -n aap-prod -o jsonpath='{.data.password}' | base64 -d)"
```

### 2. Verify All Pods are Running

```bash
# Check AAP pods
oc get pods -n aap-dev
oc get pods -n aap-qa
oc get pods -n aap-prod

# Check CI namespaces
oc get pods -n ansible-molecule-ci
oc get pods -n ee-builder-ci

# All pods should be in Running status
```

### 3. Configure AAP (Optional)

Log into each AAP instance and configure:
- Projects (SCM connections)
- Credentials
- Inventories
- Job Templates
- Execution Environments

**Tip**: Use AAP Configuration as Code for declarative configuration management.

## üìä What ArgoCD Manages

### Automatic Sync (No Manual Intervention)

‚úÖ All resources in `applications/*/` sync automatically when you push to Git
‚úÖ Drift detection - ArgoCD will auto-heal if resources are manually changed
‚úÖ Ordered deployment via sync waves within each application
‚úÖ Health checks for all resources
‚úÖ Auto-discovery of new application directories

### Making Changes to Existing Applications

```bash
# To change resources in an existing application:
1. Edit YAML files in applications/<app-name>/
2. git commit && git push
3. Wait ~3 minutes for ArgoCD to sync (automatic)

# To force immediate sync:
oc patch application <app-name> -n openshift-gitops \
  --type merge \
  --patch '{"operation":{"initiatedBy":{"username":"admin"},"sync":{}}}'
```

### Adding a New Application

```bash
# To add a completely new application:
1. Create directory: applications/my-new-app/
2. Add kustomization.yaml with resources list
3. Add your YAML resources
4. git commit && git push
5. ApplicationSet automatically discovers and creates Application

# Example structure:
# applications/my-new-app/
# ‚îú‚îÄ‚îÄ kustomization.yaml
# ‚îú‚îÄ‚îÄ namespace.yml
# ‚îî‚îÄ‚îÄ deployment.yml
```

## üîÑ Rollback

```bash
# Rollback is just a Git revert
git revert <commit-sha>
git push origin main

# ArgoCD will automatically sync to previous state within ~3 minutes
```

## üêõ Troubleshooting

### ApplicationSet Not Creating Applications

```bash
# Check ApplicationSet status
oc describe applicationset cluster -n openshift-gitops

# Verify it can reach the Git repository
oc get applicationset cluster -n openshift-gitops -o yaml

# Check for directory discovery
oc logs -n openshift-gitops \
  -l app.kubernetes.io/name=openshift-gitops-applicationset-controller \
  --tail=50
```

### Application Not Syncing

```bash
# Check specific application status
oc describe application aap-dev -n openshift-gitops

# Check ArgoCD application controller logs
oc logs -n openshift-gitops \
  -l app.kubernetes.io/name=openshift-gitops-application-controller \
  --tail=100
```

### AAP Not Starting

```bash
# Check AnsibleAutomationPlatform status
oc describe ansibleautomationplatform aap-dev -n aap-dev

# Check if operator is installed
oc get csv -n aap-dev

# Check operator logs
oc logs -n aap-dev \
  -l control-plane=controller-manager \
  --tail=100

# Check all pods in namespace
oc get pods -n aap-dev
oc describe pod <pod-name> -n aap-dev
```

### Operator Not Installing

```bash
# Check subscription status
oc describe subscription ansible-automation-platform-operator -n aap-dev

# Check install plan
oc get installplan -n aap-dev

# Check operator catalog
oc get catalogsource -n openshift-marketplace
```

## üìö Next Steps

1. ‚úÖ **Complete**: Platform infrastructure deployed via ApplicationSet
2. üîÑ **Next**: Configure AAP instances (projects, credentials, etc.)
3. üîÑ **Next**: Set up Tekton pipelines in CI namespaces
4. üîÑ **Next**: Configure GitHub webhooks for Repository CRs
5. üîÑ **Next**: Test CI/CD workflows

## üéâ Success Criteria

You're done when:

- [ ] All ArgoCD Applications show "Synced" status
- [ ] All 3 AAP instances are accessible via browser (admin login works)
- [ ] All operators show "Succeeded" status
- [ ] All pods are in "Running" state
- [ ] Can log into each AAP instance with auto-generated credentials

---

**Constitution Compliance**: ‚úì Article I (GitOps) - Everything managed by ArgoCD
**Bootstrap Pattern**: ApplicationSet with Auto-Discovery
**Manual Steps Required**: Only 2 (install GitOps operator, apply ApplicationSet)
**Time to Deploy**: ~10-15 minutes from cluster ready to AAP instances operational

